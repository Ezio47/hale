/*
 * LICENSE: This program is being made available under the LGPL 3.0 license.
 * For more information on the license, please read the following:
 * http://www.gnu.org/licenses/lgpl-3.0.txt
 * 
 * For additional information on the Model behind Mismatches, please refer to
 * the following publication(s):
 * Thorsten Reitz (2010): A Mismatch Description Language for Conceptual Schema 
 * Mapping and Its Cartographic Representation, Geographic Information Science,
 * http://www.springerlink.com/content/um2082120r51232u/
 */
package eu.xsdi.mdl.model;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

/**
 * A {@link Mismatch} object provides detailed information on non-perfect 
 * mappings, ie.e ones that contain irreconcilable differences between the 
 * mapped entities.
 * 
 * @author Thorsten Reitz
 * @version $Id$
 */
public class Mismatch {
	
	private final MismatchType type;
	
	private final UUID uuid;

	private String provenance;
	
	private String comment;
	
	private MismatchStatus status;
	
	private Reason reason = null;
	
	private Set<Consequence> consequences = null;
	
	/**
	 * @param type the specific {@link MismatchType} of the {@link Mismatch} to
	 * create.
	 */
	public Mismatch(MismatchType type) {
		this.uuid = UUID.randomUUID();
		this.type = type;
		this.consequences = new HashSet<Consequence>();
		this.status = MismatchStatus.suspected;
	}
	
	// standard methods ........................................................
	
	/**
	 * @return the {@link UUID} uniquely identifying this {@link Mismatch}.
	 */
	public UUID getUuid() {
		return uuid;
	}

	/**
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj) {
		// TODO Auto-generated method stub
		return super.equals(obj);
	}

	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append(this.type + ", reason: " + this.reason.toString());
		sb.append("Consequences (" + this.consequences.size() + ")");
		for (Consequence c : this.consequences) {
			sb.append(c.toString() + " ");
		}
		return sb.toString();
	}
	
	// getters / setters .......................................................
	
	/**
	 * @return the String describing where this {@link Mismatch} came from.
	 */
	public String getProvenance() {
		return provenance;
	}

	/**
	 * @return the comment
	 */
	public String getComment() {
		return comment;
	}

	/**
	 * @param comment the comment to set
	 */
	public void setComment(String comment) {
		this.comment = comment;
	}

	/**
	 * @return the status
	 */
	public MismatchStatus getStatus() {
		return status;
	}

	/**
	 * @param status the status to set
	 */
	public void setStatus(MismatchStatus status) {
		this.status = status;
	}

	/**
	 * @param provenance
	 */
	public void setProvenance(String provenance) {
		this.provenance = provenance;
	}
	
	/**
	 * @return the reason
	 */
	public Reason getReason() {
		return this.reason;
	}

	/**
	 * @param reason the reason to set
	 */
	public void setReason(Reason reason) {
		this.reason = reason;
	}

	/**
	 * @return the type
	 */
	public MismatchType getType() {
		return this.type;
	}

	/**
	 * @return the consequences
	 */
	public Set<Consequence> getConsequences() {
		return this.consequences;
	}

	/**
	 * This enumeration contains the types of Mismatches currently defined for
	 * the MDL.
	 * TODO: Think of a way to make this enumeration more dynamic, taking into 
	 * account possible dimensions of mismatches (type of elements they occur 
	 * on, level of abstraction they occur on, including left-hand side/right 
	 * hand side (spatial/non-spatial...))
	 */
	public enum MismatchType {
		AbstractionMismatch("Abstraction Mismatch"),
		OverlappingScopeMismatch("Overlapping Scope Mismatch"),
		IncompatibleScopeMismatch("Incompatible Scope Mismatch"),
		DelineationMismatch("Delineation Mismatch"),
		CategorizationMismatch("Categorization Mismatch"),
		AggregationLevelMismatch("Aggregation Level Mismatch"),
		StructureMismatch("Structure Mismatch"),
		ConstraintMismatch("Constraint Mismatch"),
		AttributeAssignmentMismatch("Attribute Assignment Mismatch"),
		AttributeTypeMismatch("Attribute Type Mismatch"),
		SchemaLanguageMismatch("Schema Language Mismatch");
		
		private String type;
		
		private MismatchType(String type) {
			this.type = type;
		}
		
		public String toString() {
			return this.type;
		}
	}
	
	/**
	 * The {@link MismatchStatus} allows to define whether a given {@link Mismatch}
	 * has already been confirmed or refuted (by the user). A {@link Mismatch}
	 * generated by the system always starts out as suspected.
	 */
	public enum MismatchStatus {
		/** The default state in which a Mismatch starts */
		suspected,
		/** The state in which a Mismatch is when it was confirmed (by the user) */
		confirmed,
		/** The state in which a Mismatch is when the user has refuted it. */
		refuted
	}
	
}
