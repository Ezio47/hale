<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:gml="http://www.opengis.net/gml" xmlns:sld="http://www.opengis.net/sld">
	<xs:import namespace="http://www.opengis.net/sld"/>
	<xs:import namespace="http://www.opengis.net/gml"/>
	<xs:simpleType name="MetadataType">
		<xs:annotation>
			<xs:documentation>These are some prelimiary Metadata types that can be useful as constraints.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Adress"/>
			<xs:enumeration value="Contact"/>
			<xs:enumeration value="Telephone"/>
			<xs:enumeration value="ContextAbstract"/>
			<xs:enumeration value="Title"/>
			<xs:enumeration value="Citiation"/>
			<xs:enumeration value="Extension"/>
			<xs:enumeration value="ResponsibleParty"/>
			<xs:enumeration value="LegalAccessUseConstraint"/>
			<xs:enumeration value="SecurityAccessUseConstraint"/>
			<xs:enumeration value="Keywords"/>
			<xs:enumeration value="Identification"/>
			<xs:enumeration value="Series"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="MetadataRelationType">
		<xs:annotation>
			<xs:documentation>These RelationTypes describe how the given input should match a Metadata property of a dataset to use.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="equals">
				<xs:annotation>
					<xs:documentation>The entire value needs to be equal.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="equals_partial">
				<xs:annotation>
					<xs:documentation>A part of the metadata value needs to be equal to the Constraint value.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="like">
				<xs:annotation>
					<xs:documentation>A part of the metadata value needs to be lexically close to the Constraint value.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConstraintSource">
		<xs:annotation>
			<xs:documentation>These types identify various kinds of Constraints with respect of their origin.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="parameter">
				<xs:annotation>
					<xs:documentation>Information that is gather from the payload of the request and constitutes the actual query parameters.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="protocol">
				<xs:annotation>
					<xs:documentation>Information that is gathered from the protocol layer of the request. This contains things like the HTTP_env variables.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="context">
				<xs:annotation>
					<xs:documentation>Information retrieved from the Request's context, usually through the ContextService.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="SpatialRelationType">
		<xs:annotation>
			<xs:documentation>The RelationType defines what kind of spatial relation objects need to fulfill to satisfy this criterion. In all definitions, A is the constraint's {@link Envelope}/{@link Geometry} and B is the is the candidate data's {@link Envelope}/{@link Geometry}. It corresponds to the &lt;code&gt;&amp;lt;xsd:element .*? substitutionGroup="ogc:spatialOps"&amp;gt;&lt;/code&gt; group.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Equals">
				<xs:annotation>
					<xs:documentation>A must be equal to B.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Disjoint">
				<xs:annotation>
					<xs:documentation>equal to !(Any)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Touches">
				<xs:annotation>
					<xs:documentation>A must touch B's envelope, either in one or multiple points or in a (partial) edge or any combination.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Within">
				<xs:annotation>
					<xs:documentation>B must contain A's envelope entirely.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Overlaps">
				<xs:annotation>
					<xs:documentation>A must overlap with B, i.e. FIXME.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Crosses">
				<xs:annotation>
					<xs:documentation>A must cross B, i.e. intersect on two sides.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Intersects">
				<xs:annotation>
					<xs:documentation>A must intersect B.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Contains">
				<xs:annotation>
					<xs:documentation>A must contain B entirely.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="DWithin">
				<xs:annotation>
					<xs:documentation>Candidate objects must within getDistance() of getGeometry().</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Beyond">
				<xs:annotation>
					<xs:documentation>equal to !(DWithin)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Any">
				<xs:annotation>
					<xs:documentation>equal to (Contains || Within || Touches || Equals || Intersects || Overlaps || Crosses)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="QualityConstraintType">
		<xs:annotation>
			<xs:documentation>These are ISO 19113 Quality Metadata element types. Please refer to the ISO 19113/19115 documentation for details.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Completeness"/>
			<xs:enumeration value="ConceptualConsistency"/>
			<xs:enumeration value="DomainConsistency"/>
			<xs:enumeration value="FormalConsistency"/>
			<xs:enumeration value="LogicalConsistency"/>
			<xs:enumeration value="PositionalAccuracy"/>
			<xs:enumeration value="QuantitativeAttributeAccuracy"/>
			<xs:enumeration value="TemporalConsistency"/>
			<xs:enumeration value="TopologicalConsistency"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ToleranceType">
		<xs:annotation>
			<xs:documentation>The ToleranceType indicates what kind of tolerance is being tested for. The ToleranceTypes defined so far are:
&lt;ul&gt;
&lt;li&gt;absolute: the absolute maximum numeric error that may occur. Allowable Values: unrestricted&lt;/li&gt;
&lt;li&gt;relative: the maximum relative (local) error that may occur. Allowable Values: [0..1]&lt;/li&gt;
&lt;li&gt;portion: the portion of objects not satisfying a boolean criterium. Allowable Values: [0..1]&lt;/li&gt;
&lt;li&gt;mean: the mean absolute error that may occur. Allowable Values: unrestricted&lt;/li&gt;
&lt;/ul&gt;</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="absolute">
				<xs:annotation>
					<xs:documentation>The absolute maximum numeric error that may occur. Allowable Values: unrestricted</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="relative">
				<xs:annotation>
					<xs:documentation>The maximum relative (local) error that may occur. Allowable Values: [0..1]</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="portion">
				<xs:annotation>
					<xs:documentation>The maximum portion of objects not satisfying a boolean criterium. Allowable Values: [0..1]</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="mean">
				<xs:annotation>
					<xs:documentation>mean: the mean absolute error that may occur. Allowable Values: unrestricted</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="TemporalRelationType">
		<xs:annotation>
			<xs:documentation>The RelationType defines what kind of temporal relation objects need to fulfill to satisfy this criterion. It corresponds to ISO 19136:relativePosition. In all {@link RelationType}s, A corresponds to the value contained with this {@link Constraint}, B corresponds to the value contained in the candidate dataset.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Before">
				<xs:annotation>
					<xs:documentation>A ends before B starts.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="After">
				<xs:annotation>
					<xs:documentation>A starts after B is completed.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Begins">
				<xs:annotation>
					<xs:documentation>A and B start at the same time.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Ends">
				<xs:annotation>
					<xs:documentation>A and B end at the same time.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="During">
				<xs:annotation>
					<xs:documentation>A starts after B starts and ends before B ends.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Equals">
				<xs:annotation>
					<xs:documentation>A and B start and end at the same time.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Contains">
				<xs:annotation>
					<xs:documentation>B starts after A starts and ends before A ends.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Overlaps">
				<xs:annotation>
					<xs:documentation>A starts before B but ends within B.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Meets">
				<xs:annotation>
					<xs:documentation>A ends when B starts.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="OverlappedBy">
				<xs:annotation>
					<xs:documentation>A starts after B started and ends after B ended.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MetBy">
				<xs:annotation>
					<xs:documentation>A starts when B ends.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="BegunBy">
				<xs:annotation>
					<xs:documentation>B and A start at the same time (FIXME - cross-check)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="EndedBy">
				<xs:annotation>
					<xs:documentation>B and A end at the same time (FIXME - cross-check)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="LogicalOperator">
		<xs:annotation>
			<xs:documentation>This enumeration gives the types of logical operators that can be used. In addition to those types available within the OGC Filter Encoding specification, an exclusive or (XOR) and a equals operator (EQUALS) is added.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="AND">
				<xs:annotation>
					<xs:documentation>will return true if all bound Constraints are true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="OR">
				<xs:annotation>
					<xs:documentation>will return true if at least one bound Constraint is true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="NOT">
				<xs:annotation>
					<xs:documentation>negates an expression.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="XOR">
				<xs:annotation>
					<xs:documentation>will return true if exactly one bound Constraint is true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="EQUALS">
				<xs:annotation>
					<xs:documentation>will return true if all bound Constraints return the same value.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:element name="MediatorComplexRequest" type="MediatorComplexRequest"/>
	<xs:complexType name="MediatorComplexRequest">
		<xs:sequence>
			<xs:element name="context" type="xs:string"/>
			<xs:element name="taskConcept" type="Concept"/>
			<xs:element name="constraints" type="Constraint" maxOccurs="unbounded"/>
			<xs:element name="identifer" type="UUID"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="Constraint" type="Constraint"/>
	<xs:complexType name="Constraint" abstract="true">
		<xs:sequence>
			<xs:element name="constraintSource" type="ConstraintSource"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="LanguageConstraint" type="LanguageConstraint"/>
	<xs:complexType name="LanguageConstraint">
		<xs:complexContent>
			<xs:extension base="Constraint">
				<xs:sequence>
					<xs:element name="languageCodes" type="xs:string" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="LogicalConstraint" type="LogicalConstraint"/>
	<xs:complexType name="LogicalConstraint">
		<xs:complexContent>
			<xs:extension base="Constraint">
				<xs:sequence>
					<xs:element name="boundConstraints" type="Constraint" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="logicalOperator" type="LogicalOperator"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="MetadataConstraint" type="MetadataConstraint"/>
	<xs:complexType name="MetadataConstraint">
		<xs:complexContent>
			<xs:extension base="Constraint">
				<xs:sequence>
					<xs:element name="metadataType" type="MetadataType"/>
					<xs:element name="relationType" type="MetadataRelationType"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="QualityConstraint" type="QualityConstraint"/>
	<xs:complexType name="QualityConstraint">
		<xs:complexContent>
			<xs:extension base="Constraint">
				<xs:sequence>
					<xs:element name="tolerance" type="xs:double"/>
					<xs:element name="qualityConstraintType" type="QualityConstraintType"/>
					<xs:element name="toleranceType" type="ToleranceType"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="ServiceConstraint" type="ServiceConstraint"/>
	<xs:complexType name="ServiceConstraint">
		<xs:complexContent>
			<xs:extension base="Constraint">
				<xs:sequence>
					<xs:element name="serviceDomain" type="xs:anyURI"/>
					<xs:element name="serviceOperation" type="xs:string"/>
					<xs:element name="serviceType" type="xs:string"/>
					<xs:element name="serviceVersion" type="xs:string"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="SpatialConstraint" type="SpatialConstraint"/>
	<xs:complexType name="SpatialConstraint">
		<xs:complexContent>
			<xs:extension base="Constraint">
				<xs:sequence>
					<xs:element name="bufferDistance" type="xs:double"/>
					<xs:element name="geometry" type="gml:AbstractGeometryType"/>
					<xs:element name="relationType" type="SpatialRelationType"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="TemporalConstraint" type="TemporalConstraint"/>
	<xs:complexType name="TemporalConstraint">
		<xs:complexContent>
			<xs:extension base="Constraint">
				<xs:sequence>
					<xs:element name="relationType" type="TemporalRelationType"/>
					<xs:element name="t0" type="TemporalPrimitive"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="ThematicConstraint" type="ThematicConstraint"/>
	<xs:complexType name="ThematicConstraint">
		<xs:complexContent>
			<xs:extension base="Constraint">
				<xs:sequence>
					<xs:element name="themes" type="ConceptualSchema" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="ConceptualSchema" type="ConceptualSchema"/>
	<xs:complexType name="ConceptualSchema">
		<xs:sequence>
			<xs:element name="identifier" type="xs:anyURI"/>
			<xs:element name="concepts" type="Concept" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="Concept" type="Concept"/>
	<xs:complexType name="Concept">
		<xs:sequence>
			<xs:element name="identifier" type="xs:anyURI"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="TemporalPrimitive" type="TemporalPrimitive"/>
	<xs:complexType name="TemporalPrimitive">
		<xs:sequence>
			<xs:element name="granularity" type="TemporalGranularity"/>
			<xs:element name="temporalElements" type="TemporalComplex" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:simpleType name="TemporalGranularity">
		<xs:annotation>
			<xs:documentation>The TemporalGranularity describes the precision of a certain TimePoint or TimeComplex. The values in the enumeration are an extension of those values available in ISO 19108, which carries only second to year.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="millisecond"/>
			<xs:enumeration value="second"/>
			<xs:enumeration value="minute"/>
			<xs:enumeration value="hour"/>
			<xs:enumeration value="day"/>
			<xs:enumeration value="week"/>
			<xs:enumeration value="month"/>
			<xs:enumeration value="year"/>
			<xs:enumeration value="decade"/>
			<xs:enumeration value="century"/>
			<xs:enumeration value="millenium"/>
			<xs:enumeration value="million_years"/>
			<xs:enumeration value="billion_years"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:element name="TemporalComplex" type="TemporalComplex"/>
	<xs:complexType name="TemporalComplex">
		<xs:complexContent>
			<xs:extension base="TemporalPrimitive">
				<xs:sequence/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="TimePoint" type="TimePoint"/>
	<xs:complexType name="TimePoint">
		<xs:complexContent>
			<xs:extension base="TemporalPrimitive">
				<xs:sequence>
					<xs:element name="time" type="TimeValue" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="TimeSpan" type="TimeSpan"/>
	<xs:complexType name="TimeSpan">
		<xs:complexContent>
			<xs:extension base="TemporalPrimitive">
				<xs:sequence>
					<xs:element name="t0" type="TimePoint"/>
					<xs:element name="t1" type="TimePoint"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="TimeValue" type="TimeValue"/>
	<xs:complexType name="TimeValue">
		<xs:sequence>
			<xs:element name="value" type="xs:int"/>
			<xs:element name="granularity" type="TemporalGranularity"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="PortrayalConstraint" type="PortrayalConstraint"/>
	<xs:complexType name="PortrayalConstraint">
		<xs:complexContent>
			<xs:extension base="Constraint">
				<xs:sequence>
					<xs:element name="name" type="gml:string"/>
					<xs:element ref="sld:StyledLayerDescriptor" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="UUID" type="UUID"/>
	<xs:simpleType name="UUID">
		<xs:restriction base="xs:string">
		    <xs:pattern value="[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}"/>
		</xs:restriction>
	</xs:simpleType>
</xs:schema>
