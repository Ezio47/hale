<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<script type="text/javascript"
	src="PLUGINS_ROOT/org.eclipse.help/livehelp.js">
</script>
<title>GeoServer App-Schema Plug-in for HALE - HALE vs. App-Schema</title>
</head>
<body>
	<h1>HALE vs. App-Schema</h1>

	This section will go into more detail on points where the behavior of App-Schema differs from HALE's.

	<h2>Feature Type mappings</h2>

	<p>
	The core of App-Schema's mapping file is the definition of one or more Feature Type Mappings.
	Each Feature Type Mapping specifies the name of an element in the target application schema, which
	defines the target feature type name, and a set of Attribute Mappings, controlling how the properties
	of the target type will be populated from the source.
	</p>

	<p>
	Roughly speaking, <strong>the plug-in translates type relations to Feature Type Mappings and property
	relations to Attribute Mappings</strong>. The translation logic depends on the actual relation used.
	</p>

	<p>
	In particular:

	<ul>
	<li>A <strong>Retype</strong> or <strong>Merge</strong> relation is translated to a Feature Type
	Mapping with the same name as its target type's.</li>
	<li>A <strong>Join</strong> relation is translated to multiple Feature Type Mappings, one for each
	source type participating to the join. The target feature type is determined from the Feature Chaining configuration.</li>
	</ul>
	</p>

	<a name="join"></a>
	<p>
	Note that a <strong>Join</strong> is handled differently in HALE and App-Schema:
	<ul>
	<li>In HALE, multiple source types are fused into a target type</li>
	<li>In App-Schema, each single source type is mapped to a different target type, then target types are
	further composed to form more complex types via feature chaining. In this way, each target feature type
	retains its identity and can be queried separately (via WFS, for example).</li>
	</ul>
	</p>

	<p>
	It is also worth mentioning that, although in HALE multiple join conditions can be specified for each source type,
	App-Schema only supports single-condition joins; thus, in order to be translateable to a GeoServer
	App-Schema configuration, an alignment should not contain more than one join condition for the same source type.
	</p>

	<p>See the section on <a href="./export.html#chaining">Feature Chaining</a> for more details.</p>

	<a name="id_merging"></a>
	<h2>Instance identity and merging</h2>

	<p>
	App-Schema determines the identity of a feature by looking at a special Attribute Mapping containing
	the <em>&lt;idExpression&gt;</em> directive, which defines a CQL expression that will be used to set the <strong>gml:id</strong>
	attribute of the feature (more details on this can be found in the <a href="http://docs.geoserver.org/latest/en/user/data/app-schema/mapping-file.html#idexpression-optional" target="_blank">official GeoServer documentation</a>).
	</p>

	<p>
	Note that <strong>source instances having the same gml:id are automatically merged by App-Schema</strong>. 
	The user can control the instance identity by defining a property relation that targets the <strong>gml:id</strong>
	attribute of the target feature type: the plug-in will translate it to the special <em>&lt;idExpression&gt;</em> directive, 
	rather than treating it as a regular attribute mapping. If no <em>&lt;idExpression&gt;</em> mapping is available,
	App-Schema will automatically generate a unique <strong>gml:id</strong> for each source instance.
	</p>

	<p>
	This is another important point where HALE and App-Schema differ:
	<ul>
	<li>In HALE, the number of target instances is a function of the relation between source and target
	types</li>
	<li>In App-Schema, the number of target instances is a function of the gml:id mapping</li>
	</ul>
	</p>

	<p>
	This is particularly relevant when translating an alignment that contains one or more <strong><em>Merge</em></strong> relations.
	To reproduce the same behavior in HALE and App-Schema, the user needs to construct the <strong>gml:id</strong> from
	a combination of the source properties configured as the properties to merge on in HALE (e.g. using
	a Formatted String transformation).
	</p>

	<h2>Mapping geometries</h2>

	<p>
	Special care should be taken when the target of a property relation is a geometry. For ordinary GML
	geometry properties (i.e. whose type inherits from <em>gml:GeometryPropertyType</em>), the mapping
	in both HALE and App-Schema is as simple as defining a <em>Rename</em> relation between the source
	property (be it a geometry column in a database, or a geometric attribute in a shapefile) and the
	target property.
	</p>

	<p>However, if the target geometry property is not a <em>gml:GeometryPropertyType</em>, in order to
	have the plug-in generate a working App-Schema mapping, the user must explicitly target the concrete
	geometry type contained in the geometry property. An example is the <em>gmd:EX_BoundingPolygon_Type</em>
	defined in the OGC Geographic MetaData (GMD) markup language, whose property <em>gmd:polygon</em>
	contains a geometry, but is not a <em>gml:GeometryPropertyType</em>. The correct target property to select
	here to encode e.g. a MultiPolygon would be <em>gmd:polygon/gml:AbstractGeometry/gml:MultiSurface</em>,
	and not simply <em>gmd:polygon</em>.
	</p>

	<p>
	Another point that deserves attention is the generation of GML IDs for geometries.
	In GML 3.x, all geometries must have a <strong>gml:id</strong> attribute, even though often its actual
	value is of no interest to the user. HALE satisfies this requirement by automatically generating
	GML IDs on data export. However, the App-Schema plug-in requires an explicit mapping for the geometry's
	<strong>gml:id</strong> attribute to generate a correct App-Schema configuration. This limitation
	will likely be removed in a future release.
	</p>

</body>
</html>
